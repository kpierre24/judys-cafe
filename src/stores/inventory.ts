import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { useBranchesStore } from './branches'

export interface Supplier {
  id: string
  name: string
  contact: string
  email: string
  phone: string
  address: string
  paymentTerms: string
  leadTimeDays: number
  rating: number // 1-5 stars
  totalOrders: number
  onTimeDeliveries: number
  isActive: boolean
}

export interface InventoryItem {
  id: string
  name: string
  category: 'ingredients' | 'supplies' | 'equipment'
  unit: 'kg' | 'g' | 'l' | 'ml' | 'pcs' | 'box' | 'pack'
  currentStock: number
  minimumStock: number
  maximumStock: number
  unitCost: number
  supplierId: string
  barcode?: string
  expiryDate?: Date
  batchNumber?: string
  location: string // Storage location in branch
  isActive: boolean
  lastRestocked: Date
  autoReorderEnabled: boolean
  reorderQuantity: number
}

export interface Recipe {
  id: string
  productId: string // Links to Product in sales store
  name: string
  description: string
  servingSize: number
  prepTime: number // minutes
  ingredients: RecipeIngredient[]
  instructions: string[]
  costPerServing: number
  isActive: boolean
}

export interface RecipeIngredient {
  inventoryItemId: string
  quantity: number
  unit: string
  cost: number
}

export interface PurchaseOrder {
  id: string
  supplierId: string
  orderDate: Date
  expectedDeliveryDate: Date
  actualDeliveryDate?: Date
  status: 'pending' | 'ordered' | 'received' | 'cancelled'
  items: PurchaseOrderItem[]
  subtotal: number
  tax: number
  total: number
  notes?: string
  isAutoGenerated: boolean
  branchId: string
}

export interface PurchaseOrderItem {
  inventoryItemId: string
  quantity: number
  unitCost: number
  total: number
}

export interface StockAlert {
  id: string
  type: 'low_stock' | 'expired' | 'expiring_soon' | 'overstock'
  inventoryItemId: string
  message: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  createdAt: Date
  isRead: boolean
  branchId: string
}

export const useInventoryStore = defineStore('inventory', () => {
  const branchesStore = useBranchesStore()

  // Branch-specific data
  const branchData = ref<
    Record<
      string,
      {
        inventoryItems: InventoryItem[]
        recipes: Recipe[]
        purchaseOrders: PurchaseOrder[]
        stockAlerts: StockAlert[]
      }
    >
  >({})

  // Global data (shared across branches)
  const suppliers = ref<Supplier[]>([
    {
      id: 'supplier-1',
      name: 'Coffee Bean Suppliers Co.',
      contact: 'John Smith',
      email: 'john@coffeebeanco.com',
      phone: '+1-555-0101',
      address: '123 Coffee St, Bean City',
      paymentTerms: 'Net 30',
      leadTimeDays: 5,
      rating: 4.5,
      totalOrders: 45,
      onTimeDeliveries: 42,
      isActive: true,
    },
    {
      id: 'supplier-2',
      name: 'Fresh Pastry Supply',
      contact: 'Maria Garcia',
      email: 'maria@freshpastry.com',
      phone: '+1-555-0102',
      address: '456 Bakery Ave, Flour Town',
      paymentTerms: 'Net 15',
      leadTimeDays: 2,
      rating: 4.8,
      totalOrders: 78,
      onTimeDeliveries: 76,
      isActive: true,
    },
    {
      id: 'supplier-3',
      name: 'Dairy Fresh Distribution',
      contact: 'Robert Johnson',
      email: 'robert@dairyfresh.com',
      phone: '+1-555-0103',
      address: '789 Milk Road, Cream Valley',
      paymentTerms: 'Net 21',
      leadTimeDays: 1,
      rating: 4.2,
      totalOrders: 156,
      onTimeDeliveries: 148,
      isActive: true,
    },
  ])

  // Helper functions
  function getCurrentBranchData() {
    const branchId = branchesStore.selectedBranchId
    if (!branchId) {
      throw new Error('No branch selected')
    }

    if (!branchData.value[branchId]) {
      initializeBranchData(branchId)
    }

    return branchData.value[branchId]
  }

  function initializeBranchData(branchId: string) {
    branchData.value[branchId] = {
      inventoryItems: getDefaultInventoryItems(),
      recipes: getDefaultRecipes(),
      purchaseOrders: [],
      stockAlerts: [],
    }

    // Generate initial stock alerts
    generateStockAlerts(branchId)
  }

  function getDefaultInventoryItems(): InventoryItem[] {
    const now = new Date()
    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000)
    const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000)

    return [
      {
        id: 'inv-1',
        name: 'Arabica Coffee Beans',
        category: 'ingredients',
        unit: 'kg',
        currentStock: 15.5,
        minimumStock: 10,
        maximumStock: 50,
        unitCost: 12.5,
        supplierId: 'supplier-1',
        barcode: '1234567890123',
        expiryDate: new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000),
        batchNumber: 'AB2024001',
        location: 'Storage Room A1',
        isActive: true,
        lastRestocked: new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000),
        autoReorderEnabled: true,
        reorderQuantity: 30,
      },
      {
        id: 'inv-2',
        name: 'Whole Milk',
        category: 'ingredients',
        unit: 'l',
        currentStock: 25,
        minimumStock: 20,
        maximumStock: 100,
        unitCost: 1.5,
        supplierId: 'supplier-3',
        barcode: '2345678901234',
        expiryDate: tomorrow,
        batchNumber: 'MILK240823',
        location: 'Refrigerator 1',
        isActive: true,
        lastRestocked: yesterday(),
        autoReorderEnabled: true,
        reorderQuantity: 50,
      },
      {
        id: 'inv-3',
        name: 'Croissants (Frozen)',
        category: 'ingredients',
        unit: 'pcs',
        currentStock: 48,
        minimumStock: 30,
        maximumStock: 200,
        unitCost: 0.75,
        supplierId: 'supplier-2',
        barcode: '3456789012345',
        expiryDate: nextWeek,
        batchNumber: 'CROIS2024',
        location: 'Freezer 1',
        isActive: true,
        lastRestocked: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000),
        autoReorderEnabled: true,
        reorderQuantity: 100,
      },
      {
        id: 'inv-4',
        name: 'Paper Cups (12oz)',
        category: 'supplies',
        unit: 'pcs',
        currentStock: 150,
        minimumStock: 100,
        maximumStock: 1000,
        unitCost: 0.15,
        supplierId: 'supplier-2',
        barcode: '4567890123456',
        location: 'Storage Room B2',
        isActive: true,
        lastRestocked: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
        autoReorderEnabled: true,
        reorderQuantity: 500,
      },
      {
        id: 'inv-5',
        name: 'Espresso Machine Filters',
        category: 'supplies',
        unit: 'pcs',
        currentStock: 8,
        minimumStock: 10,
        maximumStock: 50,
        unitCost: 2.5,
        supplierId: 'supplier-1',
        barcode: '5678901234567',
        location: 'Equipment Storage',
        isActive: true,
        lastRestocked: new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000),
        autoReorderEnabled: true,
        reorderQuantity: 25,
      },
    ]
  }

  function getDefaultRecipes(): Recipe[] {
    return [
      {
        id: 'recipe-1',
        productId: '1', // Cappuccino
        name: 'Classic Cappuccino',
        description: 'Traditional Italian cappuccino with perfect foam',
        servingSize: 1,
        prepTime: 3,
        ingredients: [
          {
            inventoryItemId: 'inv-1',
            quantity: 18,
            unit: 'g',
            cost: 0.225,
          },
          {
            inventoryItemId: 'inv-2',
            quantity: 150,
            unit: 'ml',
            cost: 0.225,
          },
        ],
        instructions: [
          'Grind 18g of coffee beans to fine consistency',
          'Extract double espresso shot (30ml) in 25-30 seconds',
          'Steam 150ml milk to 65°C with microfoam',
          'Pour steamed milk into espresso, creating art pattern',
        ],
        costPerServing: 0.45,
        isActive: true,
      },
      {
        id: 'recipe-2',
        productId: '4', // Croissant
        name: 'Warmed Croissant',
        description: 'Freshly baked croissant served warm',
        servingSize: 1,
        prepTime: 1,
        ingredients: [
          {
            inventoryItemId: 'inv-3',
            quantity: 1,
            unit: 'pcs',
            cost: 0.75,
          },
        ],
        instructions: [
          'Preheat oven to 180°C',
          'Place frozen croissant on baking tray',
          'Bake for 12-15 minutes until golden brown',
          'Serve immediately while warm',
        ],
        costPerServing: 0.75,
        isActive: true,
      },
    ]
  }

  function yesterday(): Date {
    const date = new Date()
    date.setDate(date.getDate() - 1)
    return date
  }

  // Computed properties
  const inventoryItems = computed(() => {
    try {
      return getCurrentBranchData().inventoryItems
    } catch {
      return []
    }
  })

  const recipes = computed(() => {
    try {
      return getCurrentBranchData().recipes
    } catch {
      return []
    }
  })

  const purchaseOrders = computed(() => {
    try {
      return getCurrentBranchData().purchaseOrders
    } catch {
      return []
    }
  })

  const stockAlerts = computed(() => {
    try {
      return getCurrentBranchData().stockAlerts
    } catch {
      return []
    }
  })

  const unreadAlerts = computed(() => {
    return stockAlerts.value.filter((alert) => !alert.isRead)
  })

  const criticalAlerts = computed(() => {
    return stockAlerts.value.filter((alert) => alert.severity === 'critical' && !alert.isRead)
  })

  const lowStockItems = computed(() => {
    return inventoryItems.value.filter(
      (item) => item.currentStock <= item.minimumStock && item.isActive,
    )
  })

  const expiredItems = computed(() => {
    const now = new Date()
    return inventoryItems.value.filter(
      (item) => item.expiryDate && item.expiryDate < now && item.isActive,
    )
  })

  const expiringSoonItems = computed(() => {
    const now = new Date()
    const threeDaysFromNow = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000)

    return inventoryItems.value.filter(
      (item) =>
        item.expiryDate &&
        item.expiryDate > now &&
        item.expiryDate <= threeDaysFromNow &&
        item.isActive,
    )
  })

  const supplierPerformance = computed(() => {
    return suppliers.value.map((supplier) => ({
      ...supplier,
      onTimePercentage:
        supplier.totalOrders > 0 ? (supplier.onTimeDeliveries / supplier.totalOrders) * 100 : 0,
    }))
  })

  // Actions
  function generateStockAlerts(branchId: string) {
    const data = branchData.value[branchId]
    if (!data) return

    data.stockAlerts = []

    data.inventoryItems.forEach((item) => {
      // Low stock alerts
      if (item.currentStock <= item.minimumStock) {
        data.stockAlerts.push({
          id: `alert-${Date.now()}-${item.id}`,
          type: 'low_stock',
          inventoryItemId: item.id,
          message: `${item.name} is running low (${item.currentStock} ${item.unit} remaining)`,
          severity: item.currentStock <= item.minimumStock * 0.5 ? 'critical' : 'high',
          createdAt: new Date(),
          isRead: false,
          branchId,
        })
      }

      // Expiry alerts
      if (item.expiryDate) {
        const now = new Date()
        const daysUntilExpiry = Math.ceil(
          (item.expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24),
        )

        if (daysUntilExpiry <= 0) {
          data.stockAlerts.push({
            id: `alert-${Date.now()}-exp-${item.id}`,
            type: 'expired',
            inventoryItemId: item.id,
            message: `${item.name} has expired (Batch: ${item.batchNumber})`,
            severity: 'critical',
            createdAt: new Date(),
            isRead: false,
            branchId,
          })
        } else if (daysUntilExpiry <= 3) {
          data.stockAlerts.push({
            id: `alert-${Date.now()}-exp-soon-${item.id}`,
            type: 'expiring_soon',
            inventoryItemId: item.id,
            message: `${item.name} expires in ${daysUntilExpiry} day(s) (Batch: ${item.batchNumber})`,
            severity: daysUntilExpiry === 1 ? 'high' : 'medium',
            createdAt: new Date(),
            isRead: false,
            branchId,
          })
        }
      }
    })
  }

  function checkAutoReorder(branchId: string) {
    const data = branchData.value[branchId]
    if (!data) return

    const itemsToReorder = data.inventoryItems.filter(
      (item) => item.autoReorderEnabled && item.currentStock <= item.minimumStock && item.isActive,
    )

    itemsToReorder.forEach((item) => {
      generatePurchaseOrder(item, branchId)
    })
  }

  function generatePurchaseOrder(item: InventoryItem, branchId: string) {
    const supplier = suppliers.value.find((s) => s.id === item.supplierId)
    if (!supplier) return

    const orderDate = new Date()
    const expectedDeliveryDate = new Date(
      orderDate.getTime() + supplier.leadTimeDays * 24 * 60 * 60 * 1000,
    )

    const orderItem: PurchaseOrderItem = {
      inventoryItemId: item.id,
      quantity: item.reorderQuantity,
      unitCost: item.unitCost,
      total: item.reorderQuantity * item.unitCost,
    }

    const subtotal = orderItem.total
    const tax = subtotal * 0.08
    const total = subtotal + tax

    const purchaseOrder: PurchaseOrder = {
      id: `po-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      supplierId: supplier.id,
      orderDate,
      expectedDeliveryDate,
      status: 'pending',
      items: [orderItem],
      subtotal,
      tax,
      total,
      notes: `Auto-generated order for ${item.name} - Low stock alert`,
      isAutoGenerated: true,
      branchId,
    }

    const data = branchData.value[branchId]
    data.purchaseOrders.push(purchaseOrder)
  }

  function updateStock(itemId: string, newQuantity: number, operation: 'restock' | 'consume') {
    const data = getCurrentBranchData()
    const item = data.inventoryItems.find((i) => i.id === itemId)

    if (!item) return false

    if (operation === 'restock') {
      item.currentStock += newQuantity
      item.lastRestocked = new Date()
    } else if (operation === 'consume') {
      if (item.currentStock >= newQuantity) {
        item.currentStock -= newQuantity
      } else {
        return false // Insufficient stock
      }
    }

    // Regenerate alerts after stock change
    generateStockAlerts(branchesStore.selectedBranchId!)

    // Check if auto-reorder is needed
    if (item.currentStock <= item.minimumStock && item.autoReorderEnabled) {
      checkAutoReorder(branchesStore.selectedBranchId!)
    }

    return true
  }

  function scanBarcode(barcode: string) {
    const data = getCurrentBranchData()
    return data.inventoryItems.find((item) => item.barcode === barcode)
  }

  function markAlertAsRead(alertId: string) {
    const data = getCurrentBranchData()
    const alert = data.stockAlerts.find((a) => a.id === alertId)
    if (alert) {
      alert.isRead = true
    }
  }

  function addInventoryItem(item: Omit<InventoryItem, 'id' | 'lastRestocked'>) {
    const data = getCurrentBranchData()
    const newItem: InventoryItem = {
      ...item,
      id: `inv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      lastRestocked: new Date(),
    }
    data.inventoryItems.push(newItem)

    // Regenerate alerts
    generateStockAlerts(branchesStore.selectedBranchId!)
  }

  function updateInventoryItem(itemId: string, updates: Partial<InventoryItem>) {
    const data = getCurrentBranchData()
    const itemIndex = data.inventoryItems.findIndex((i) => i.id === itemId)
    if (itemIndex !== -1) {
      data.inventoryItems[itemIndex] = { ...data.inventoryItems[itemIndex], ...updates }

      // Regenerate alerts
      generateStockAlerts(branchesStore.selectedBranchId!)
    }
  }

  function addSupplier(supplier: Omit<Supplier, 'id' | 'totalOrders' | 'onTimeDeliveries'>) {
    const newSupplier: Supplier = {
      ...supplier,
      id: `supplier-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      totalOrders: 0,
      onTimeDeliveries: 0,
    }
    suppliers.value.push(newSupplier)
  }

  function updateSupplier(supplierId: string, updates: Partial<Supplier>) {
    const supplierIndex = suppliers.value.findIndex((s) => s.id === supplierId)
    if (supplierIndex !== -1) {
      suppliers.value[supplierIndex] = { ...suppliers.value[supplierIndex], ...updates }
    }
  }

  function addRecipe(recipe: Omit<Recipe, 'id' | 'costPerServing'>) {
    const data = getCurrentBranchData()

    // Calculate cost per serving
    const costPerServing = recipe.ingredients.reduce((total, ingredient) => {
      return total + ingredient.cost
    }, 0)

    const newRecipe: Recipe = {
      ...recipe,
      id: `recipe-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      costPerServing,
    }

    data.recipes.push(newRecipe)
  }

  function updateRecipe(recipeId: string, updates: Partial<Recipe>) {
    const data = getCurrentBranchData()
    const recipeIndex = data.recipes.findIndex((r) => r.id === recipeId)
    if (recipeIndex !== -1) {
      const updatedRecipe = { ...data.recipes[recipeIndex], ...updates }

      // Recalculate cost per serving if ingredients changed
      if (updates.ingredients) {
        updatedRecipe.costPerServing = updatedRecipe.ingredients.reduce((total, ingredient) => {
          return total + ingredient.cost
        }, 0)
      }

      data.recipes[recipeIndex] = updatedRecipe
    }
  }

  return {
    // State
    suppliers,

    // Computed
    inventoryItems,
    recipes,
    purchaseOrders,
    stockAlerts,
    unreadAlerts,
    criticalAlerts,
    lowStockItems,
    expiredItems,
    expiringSoonItems,
    supplierPerformance,

    // Actions
    generateStockAlerts,
    checkAutoReorder,
    updateStock,
    scanBarcode,
    markAlertAsRead,
    addInventoryItem,
    updateInventoryItem,
    addSupplier,
    updateSupplier,
    addRecipe,
    updateRecipe,
    generatePurchaseOrder,
  }
})
